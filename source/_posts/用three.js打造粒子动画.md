---
title: 用three.js打造粒子动画
date: 2018-01-14
tags: [js, canvas]
categories: 技术
---

# 用three.js打造粒子动画

最近为了给以后的运营需求做技术积累，对3D动画在组内的落地进行了一些研究。切入点是粒子动画，这是最容易实现的3D动画。

最后做出了一些还可以的效果。把其中的经验与坑记录一下
由于只在内网上线，所以暂时用gif来表示（gif掉帧比较大，真实还是非常流畅的）。
![hi](http://odf9m3avc.bkt.clouddn.com/hi.gif)


## 基础知识

这里不再赘述 webGL底层与图形学，我们这里说three的基础

three.js构成一个物体的本质是三样
1.Geometry 几何 负责物体长什么样子
2.material 材料 负责物体对光线的交互
3.mesh 网格 geo与mat的承载者

粒子动画的粒子构成有三种思路

1. Points + Vector3 

最常用的一种，一个父级对象作为粒子系统，子为坐标点矢量

好处是方便建立，开一个随机数组，xyz三值赋值即可

缺点是不方便为控制每一个粒子，如果想对每个粒子的颜色大小等进行控制无法达到，因为Vector对象本质上是矢量，不包含这些东西，矢量擅长的事情是位移。

2. Group + Mesh 

这种方式的优点是

可以操控所有的粒子属性，大而全，就像一个IDE，你能做的事情都帮你做了，建立起来也和Vector非常相似，十分容易。

缺点是非常耗费性能，2D动画的性能一般由计算和渲染决定，而由于GPU太擅长矩阵计算了，计算耗费相对于渲染微不足道。渲染性能耗费主要就在于GPU要计算多少面，而每一个Mesh对象又是独立的，如果采用MergeGeometry的方法则无法控制每一个粒子。

3. BufferGeometry + ShaderMaterial

使用缓冲区来降低性能消耗，还能完整控制每个属性。

就是难写...
![](http://odf9m3avc.bkt.clouddn.com/%E5%90%83%E6%83%8A.jpg)


**BufferGeometry**要求Float32Array，为3 * n矩阵来确定位置信息，颜色与大小等则同样为 1* n的矩阵。与上面两种直接给实例的方式不一样。
举个🌰
```javascript
const v = new THREE.Vector3();
const length = n;
let rs = new Array(length * 3);
for (let i = 0; i < length; i++) {
    v.x = x
    v.y = y;
    v.z = z;
    v.toArray(rs, i * 3)
}
return rs
```
这里我们用一个Vector3.toArray来帮我们来完成矩阵排列，当然这样就是要你不要
用 index index + 1 index + 2 的方式来表示xyz，因为在真实开发环境中可能有复杂情况让你不是那么好算。

这里返回一个普通array 你可以直接用 new Float32Array()或者用原型链方法from来进行array 到 float。

**ShaderMaterial**就更麻烦了,因为他涉及到我们需要自己写用GLSL语言来写着色器，它可以让你充分的发挥GPU的威力但是对于习惯了写JS的一些fe来说，突然去写类C的这样一种语言还是会有一些不适应的。

## 开发难点处理

1. 模型算法

three.js帮你把底层基本上能做的事，都做了，封装的也非常好，虽说官方文档有点云里雾里的但是跟着看看源码也就明白了，作者的源码写的是真心话简单朴实不炫技。

那么对于我们开发者的难度就在于算法上了，算法有两个问题

1.1 物体建模

有UI支撑帮忙建模自然最好，但是从经验来看还是靠不住的；我们需要自己用算法实现物体的效果，比如说一个渐变缩小的金字塔，他的每个粒子之间的的关系方程式，需要我们花费时间去处理。这里面就涉及到调参的问题，如何快速的精确调整与展示结果，直接影响到我们的开发效率，这里three官方用的是 [dat.gui](https://github.com/dataarts/dat.gui)，能解决我们所需要的快速展示结果的需求，问题就是需要花费时间添加代码。理想来说应该可以集成在一个框架中，来减少开发成本，但是目前生态不算完善，可以考虑自己造轮子。

1.2 数据生成

随机数据的生成以及对数据状态的变化，也是一个需要解决的部分，建立好的模型，怎么去进行动画。位移、大小、颜色、形变等等，都需要一个规律的算法来实现，简单的补间动画我们可以使用[TWEEN](https://github.com/tweenjs/tween.js)来实现，但是真正那些好看的效果，还是需要我们通过各种三角函数、矩阵变换等来实现，这里暂时没有什么太好的处理方法，只能说是多看实例，积累算法。

2. 动画思路

在动画各幕对象差很多的情况该怎么办？

在我的动画中，四幕粒子数约为 10k, .5k, 2k, 3k ，那么这里涉及到第一幕多出来的粒子怎么处理？让他飞出去在销毁？毕竟多这么多挺费内存的。但是我没有这么干，而是循环原样摆放，也就是说我的10k个粒子，在第二幕其实摆了20遍，只不过他们重合了，看起来像只有很少。

有两个原因：

1. 不缺这点性能

GPU前向算法会将不出现的物体不进行渲染。10k粒子对GPU不算啥事。

2. 工程难度

如果我反复操作粒子总量更加困难不说，也容易出bug延误工期，现在都敏捷开发，一天出80分的活，也不会让你一周干到100分，毕竟可以后续再迭代。

## 工程化考量

本质上来说Three.js像是Jq，他的定位是一个库，3D的开发模式还是比较传统，没有React等这样的革新开发模型的框架出现，也不想2D有CreateJS这样的容错很高的框架存在，整个生态还是比较原始的一片处女地，在错误捕捉、性能提升、开发体验上暂时还都需要开发者自己来完成。

我自己把日常工作中沉淀了一下，做一个专为动画设计的工具库，[Christina.js](https://github.com/YuriTu/Christina)目前还很不完善， 只是集成了一些我觉得常用到的操作与算法，希望能对开发效率上有一定的提升。

## 总结
总体上这次开发还是挺仓促的，一共10/人/天，性能上没有任何优化，在内存上也有很多浪费和需要处理的地方，这都需要在后续的开发中再优化，在提高开发效果和快速成果展示上也还需要继续优化。但总体上我还是满意的。

希望本文能给你一些灵感。



 


